program arbolAVL;

uses crt;

type

  // Nodo
  PTNode = ^TNode;
  TNode = record
    ID: integer;
    right: PTNode;
    left: PTNode;
    height: Integer;



  end;

  // Arbol
  Tree = class
    private

    public
      root: PTNode;

      // Creacion
      constructor Create;


      // Insersion
      procedure Agregar(id: Integer);
      function recursive(item: PTnode; node: PTnode): PTNode ;
      function getHeight(node: PTnode): Integer;
      function getMaxHeight(leftNode: Integer; rightNode: Integer): Integer;

      //Rotaciones
      function rotateleft(node1: PTnode): PTnode;
      function rotateright(node2: PTnode): PTnode;
      function doubleleft(node: PTnode): PTnode;
      function doubleright(node: PTnode): PTnode;


      // Destructor
      destructor Destroy; override;
      procedure LiberarArbol(nodo: PTnode);

      // Recorridos y busqueda
      function Buscar(id: Integer): Boolean;
      procedure RecorridoInOrder;
      procedure RecorridoPreOrder;
      procedure RecorridoPostOrder;

      procedure inOrderRecursive(curr: PTNode);
      procedure preOrderRecursive(curr: PTNode);
      procedure postOrderRecursive(curr: PTNode);
  end;



// ---------------------- CREACION ------------------
constructor Tree.Create;
begin
  root := nil;

end;

procedure Tree.Agregar(id: Integer);
var
  node: PTNode;
begin
  new(node);
  node^.ID := id;
  node^.right := nil;
  node^.left := nil;
  node^.height := 0;


  root := recursive(node, root);


end;

function Tree.getHeight(node: PTNode): Integer;
begin
  if node = nil then
  begin
    Exit(-1)
  end
  else
  begin
    Exit(node^.height)
  end;
end;

function Tree.getMaxHeight(leftNode: Integer; rightNode: Integer): Integer;
begin
  if leftNode > RightNode then
    Exit(leftNode)
  else
    Exit(rightNode);

end;

function Tree.recursive(item: PTNode; node: PTNode): PTnode;
begin

  if (node = nil) then
     node := item


  // Caso 6 < 9, insertar lado izquierdo
  else if item^.ID < node^.ID then
  begin
    node^.left := recursive(item, node^.left);

    // Rotacion
    if GetHeight(node^.left) - GetHeight(node^.right) = 2 then
    begin
      // derecho
      if item^.ID < node^.left^.ID then
        node := rotateright(node)
      else
        node := doubleright(node);

    end;

  end

  // Caso 10 > 8, insertar lado derecho
  else if item^.ID > node^.ID then
  begin
    node^.right := recursive(item, node^.right);

    //Rotacion
    if GetHeight(node^.right) - GetHeight(node^.left) = 2 then
    begin
      // izquierdo
      if item^.ID > node^.right^.ID then
        node := rotateleft(node)
      else
        node := doubleleft(node);

    end;
  end
  else
    Writeln('Elemento ya existe en el arbol');

  node^.height := getMaxHeight(GetHeight(node^.left), GetHeight(node^.right)) + 1;
  Exit(node);








end;


// ------------------ ROTACIONES ----------------------
function Tree.rotateright(node2: PTnode): PTnode;
var
  node1: PTnode;
begin
  node1 := node2^.left;
  node2^.left := node1^.right;
  node1^.right := node2;
  node2^.height := getMaxHeight(GetHeight(node2^.left), GetHeight(node2^.right)) + 1;
  node1^.height := getMaxHeight(GetHeight(node1^.left), node2^.height) + 1;
  Exit(node1)


end;

function Tree.rotateleft(node1: PTnode): PTnode;
var
  node2: PTnode;
begin
  node2 := node1^.right;
  node1^.right := node2^.left;
  node2^.left := node1;

  node1^.height := getMaxHeight(getHeight(node1^.left), getHeight(node1^.right)) + 1;
  node2^.height := getMaxHeight(getHeight(node2^.right), node1^.height) + 1;
  Exit(node2);


end;

function Tree.doubleright(node: PTnode): PTnode;
begin
  node^.right := rotateLeft(node^.right);
  Exit(node);
end;

function Tree.doubleleft(node: PTnode): PTnode;
begin
  node^.left := rotateRight(node^.left);
  Exit(node);
end;

// ------------------ Destructor ------------
destructor Tree.Destroy;
begin
  LiberarArbol(root);
  inherited Destroy;

end;

procedure Tree.LiberarArbol(nodo: PTNode);
begin
  if nodo <> nil then
  begin
    LiberarArbol(nodo^.left);
    LIberarArbol(nodo^.right);
    Dispose(nodo);
  end;

end;

// --------------------- Busqueda -------------
function Tree.Buscar(id: Integer): Boolean;
var
  actual: PTNode;
begin
  actual := root;

  while actual <> nil do
  begin
    if id = actual^.ID then
     Exit(True)
    else if id < actual^.ID then
     actual := actual^.left
    else
     actual := actual^.right;

  end;
  Result := False;

end;

// -------------------- Recorrido InOrden --------------
procedure Tree.RecorridoInOrder;
begin
  inOrderRecursive(root);

end;


procedure Tree.inOrderRecursive(curr: PTNode);
begin

  // Curr: 70

  if curr^.left <> nil then
  begin

    inOrderRecursive(curr^.left);
  end;

  // Mostrando: 20, 30, 40, 50

  // Mostrar el nodo
  writeln('Nodo: ', curr^.ID);

  if curr^.right<> nil then
  begin
    inOrderRecursive(curr^.right);
  end;


end;

// ------------------ Recorrido PreOrder ----------------
procedure Tree.RecorridoPreOrder;
begin
  preOrderRecursive(root);

end;


procedure Tree.preOrderRecursive(curr: PTNode);
begin

  // Curr: 50, 40

  // Mostrando: 50, 30 , 20 , 40

  // Mostrar el nodo
  writeln('Nodo: ', curr^.ID);

  if curr^.left <> nil then
  begin
    preOrderRecursive(curr^.left);
  end;


  if curr^.right<> nil then
  begin
    preOrderRecursive(curr^.right);
  end;


end;


// ---------------- Recorrido PostOrder -----------
procedure Tree.RecorridoPostOrder;
begin
  postOrderRecursive(root);

end;


procedure Tree.postOrderRecursive(curr: PTNode);
begin

  // Curr: 50, 70, 80



  if curr^.left <> nil then
  begin
    postOrderRecursive(curr^.left);
  end;


  if curr^.right<> nil then
  begin
    postOrderRecursive(curr^.right);
  end;

  // Mostrar: 20, 40, 30, 60, 80, 70, 50

  // Mostrar el nodo
  writeln('Nodo: ', curr^.ID);


end;

var
  miArbol: Tree;
begin

  miArbol := Tree.Create;

  // Agregar elementos
  miArbol.Agregar(1);
  miArbol.Agregar(2);
  miArbol.Agregar(3);
  miArbol.Agregar(4);
  miArbol.Agregar(5);
  miArbol.Agregar(6);
  miArbol.Agregar(7);


  // Insertar repetido
  miArbol.Agregar(7);

  writeln('Recorrido In Order');
  miArbol.RecorridoInOrder;
  writeln('------');

  writeln('Recorrido Pre Order');
  miArbol.RecorridoPreOrder;
  writeln('------');

  writeln('Recorrido Post Order');
  miArbol.RecorridoPostOrder;
  writeln('------');

  if miArbol.Buscar(40) then
  begin
    writeln('Si existe');
  end;
  readkey;




end.