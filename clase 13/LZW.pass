program lzw;

uses
  Classes, SysUtils, crt;

type
  // Diccionario que almacena cadenas
  TDictionary = array of string;

  // Tipo de dato para códigos de compresión (16 bits)
  TCode = Word;
  // Arreglo de códigos comprimidos
  TCodeArray = array of TCode;

  // Clase principal del compresor LZW
  TCompresorLZW = class
  private
  public
    // Inicializa el diccionario con los 256 caracteres ASCII
    procedure Inicializar(var dict: TDictionary);

    // Busca una cadena en el diccionario, devuelve su posición o -1 si no existe
    function Buscar(const dict: TDictionary; const cadena: string): Integer;

    // Agrega una nueva cadena al diccionario
    procedure Agregar(var dict: TDictionary; const cadena: string);

    // Comprime un texto en una secuencia de códigos
    function Comprimir(const texto: string): TCodeArray;

    // Descomprime una secuencia de códigos en texto original
    function Descomprimir(const codigos: TCodeArray): string;
  end;

{======================== IMPLEMENTACIÓN DE MÉTODOS ========================}

procedure TCompresorLZW.Inicializar(var dict: TDictionary);
var
  i: Integer;
begin
  // Crea el diccionario con 256 entradas iniciales (caracteres ASCII)
  SetLength(dict, 256);
  for i := 0 to 255 do
    dict[i] := Chr(i);  // Asigna cada carácter ASCII
end;

function TCompresorLZW.Buscar(const dict: TDictionary; const cadena: string): Integer;
var
  i: Integer;
begin
  // Recorre el diccionario buscando la cadena exacta
  for i := 0 to High(dict) do
    if dict[i] = cadena then
      Exit(i); // Retorna su posición si la encuentra
  Result := -1; // Si no se encuentra, retorna -1
end;

procedure TCompresorLZW.Agregar(var dict: TDictionary; const cadena: string);
begin
  // Aumenta el tamaño del diccionario y agrega una nueva cadena
  SetLength(dict, Length(dict) + 1);
  dict[High(dict)] := cadena;
end;

function TCompresorLZW.Comprimir(const texto: string): TCodeArray;
var
  dict: TDictionary;
  entrada: string;
  caracter: Char;
  codigo: Integer;
  siguienteCodigo: Integer;
  i: Integer;
  resultado: array of TCode;
begin
  // Inicializa el diccionario con ASCII
  Inicializar(dict);
  siguienteCodigo := 256;
  SetLength(resultado, 0);
  entrada := '';

  //  Recorre cada carácter del texto
  for i := 1 to Length(texto) do
  begin
    caracter := texto[i];

    // Verifica si "entrada + caracter" existe en el diccionario
    codigo := Buscar(dict, entrada + caracter);

    if codigo <> -1 then
    begin
      // Si existe, amplía la cadena (se sigue formando una más larga)
      entrada := entrada + caracter;
    end
    else
    begin
      // Si no existe, agrega el código de "entrada" al resultado
      codigo := Buscar(dict, entrada);
      if codigo <> -1 then
      begin
        SetLength(resultado, Length(resultado) + 1);
        resultado[High(resultado)] := codigo;

        // Agrega la nueva combinación al diccionario (entrada + caracter)
        if siguienteCodigo < 65536 then // Límite de 16 bits
        begin
          Agregar(dict, entrada + caracter);
          Inc(siguienteCodigo);
        end;
      end;
      // Reinicia "entrada" con el carácter actual
      entrada := caracter;
    end;
  end;

  // Agrega el último código pendiente
  if entrada <> '' then
  begin
    codigo := Buscar(dict, entrada);
    SetLength(resultado, Length(resultado) + 1);
    resultado[High(resultado)] := codigo;
  end;

  Result := resultado; // Devuelve la secuencia de códigos comprimidos
end;

function TCompresorLZW.Descomprimir(const codigos: TCodeArray): string;
var
  dict: TDictionary;
  anterior, actual: string;
  codigoAnterior, codigoActual: TCode;
  i: Integer;
  siguienteCodigo: Integer;
begin
  // Inicializa el diccionario ASCII
  Inicializar(dict);
  siguienteCodigo := 256;

  if Length(codigos) = 0 then
    Exit; // Si no hay códigos, no hay texto

  // Comienza con el primer código
  codigoAnterior := codigos[0];
  anterior := dict[codigoAnterior];
  Result := anterior;

  // Recorre los demás códigos
  for i := 1 to High(codigos) do
  begin
    codigoActual := codigos[i];

    // Si el código existe en el diccionario, lo obtiene
    if codigoActual < Length(dict) then
      actual := dict[codigoActual]
    // Si el código no existe, se genera según la regla LZW
    else if codigoActual = siguienteCodigo then
      actual := anterior + anterior[1]
    else
      raise Exception.Create('Error: Código inválido en la descompresión');

    // Agrega la cadena al resultado
    Result := Result + actual;

    // Agrega nueva entrada al diccionario: anterior + primer caracter de actual
    if siguienteCodigo < 65536 then
    begin
      Agregar(dict, anterior + actual[1]);
      Inc(siguienteCodigo);
    end;

    // Actualiza valores para la siguiente iteración
    anterior := actual;
    codigoAnterior := codigoActual;
  end;
end;

{======================== FUNCIONES AUXILIARES ========================}

// Convierte los códigos comprimidos a un texto legible (separado por comas)
function CodigosAString(const codigos: TCodeArray): string;
var
  i: Integer;
begin
  Result := '';
  for i := 0 to High(codigos) do
  begin
    if i > 0 then
      Result := Result + ',';
    Result := Result + IntToStr(codigos[i]);
  end;
end;

// Guarda los códigos comprimidos en un archivo de texto (.txt)
procedure GuardarComoTxt(const codigos: TCodeArray; const nombreArchivo: string);
var
  f: TextFile;
  i: Integer;
begin
  AssignFile(f, nombreArchivo);
  Rewrite(f);
  for i := 0 to High(codigos) do
  begin
    Write(f, codigos[i]);
    if i < High(codigos) then
      Write(f, ',');
  end;
  CloseFile(f);
end;

// Guarda los códigos comprimidos en formato binario (.bin)
procedure GuardarComoBin(const codigos: TCodeArray; const nombreArchivo: string);
var
  f: File of Word;
  i: Integer;
begin
  AssignFile(f, nombreArchivo);
  Rewrite(f);
  for i := 0 to High(codigos) do
    Write(f, codigos[i]);
  CloseFile(f);
end;

{======================== PROGRAMA PRINCIPAL ========================}

var
  compresor: TCompresorLZW;
  textoOriginal, textoDescomprimido: string;
  codigosComprimidos: TCodeArray;
  i: Integer;
begin
  compresor := TCompresorLZW.Create;

  {===================== EJEMPLO 1 =====================}
  textoOriginal := 'ABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCDABCABCD';
  Writeln('=== EJEMPLO 1 ===');
  Writeln('Texto original: ', textoOriginal);

  codigosComprimidos := compresor.Comprimir(textoOriginal);
  Writeln('Códigos comprimidos: ', CodigosAString(codigosComprimidos));

  textoDescomprimido := compresor.Descomprimir(codigosComprimidos);
  Writeln('Texto descomprimido: ', textoDescomprimido);

  // Guardar resultados
  GuardarComoTxt(codigosComprimidos, 'comprimido1.txt');
  GuardarComoBin(codigosComprimidos, 'comprimido1.bin');
  Writeln('Archivos guardados: comprimido1.txt y comprimido1.bin');

  {===================== EJEMPLO 2 =====================}
  textoOriginal := 'TOBEORNOTTOBEORTOBEORNOT';
  Writeln(#10'=== EJEMPLO 2 ===');
  Writeln('Texto original: ', textoOriginal);

  codigosComprimidos := compresor.Comprimir(textoOriginal);
  Writeln('Códigos comprimidos: ', CodigosAString(codigosComprimidos));

  textoDescomprimido := compresor.Descomprimir(codigosComprimidos);
  Writeln('Texto descomprimido: ', textoDescomprimido);

  {===================== EJEMPLO 3 =====================}
  textoOriginal := 'EL ALGORITMO LZW ES UN ALGORITMO DE COMPRESION MUY EFICIENTE';
  Writeln(#10'=== EJEMPLO 3 ===');
  Writeln('Texto original: ', textoOriginal);

  codigosComprimidos := compresor.Comprimir(textoOriginal);
  Writeln('Primeros códigos:');
  for i := 0 to 30 do
    if i <= High(codigosComprimidos) then
      Write(codigosComprimidos[i], ' ');
  Writeln;

  textoDescomprimido := compresor.Descomprimir(codigosComprimidos);
  Writeln('Texto descomprimido: ', textoDescomprimido);

  {===================== EJEMPLO 4 =====================}
  textoOriginal := 'UNUNUN';
  Writeln(#10'=== EJEMPLO 4 ===');
  Writeln('Texto original: ', textoOriginal);

  codigosComprimidos := compresor.Comprimir(textoOriginal);
  Writeln('Códigos comprimidos: ', CodigosAString(codigosComprimidos));

  textoDescomprimido := compresor.Descomprimir(codigosComprimidos);
  Writeln('Texto descomprimido: ', textoDescomprimido);

  ReadKey;
end.
